# Type

　型判定する。

<!-- more -->

* https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects

```javascript
const AsyncFunction = (async()=>{}).constructor
const GeneratorFunction = (function*(){yield undefined;}).constructor;
const AsyncGeneratorFunction = (async function*(){yield undefined;}).constructor;

Type.isNullOrUndefined(v)
Type.isPrimitive(v)
Type.isClass(v)           // クラスである（インスタンスでない）
Type.isInstance(v)        // 何らかのクラスのインスタンスである（クラスでない）
Type.isInstance(v, cls)   // 指定したclsのインスタンスである
Type.isFunction(v)
Type.isSyncFunction(v)				// return 
Type.isAsyncFunction(v)				// return 
Type.isGeneratorFunction(v)			// return isSyncGeneratorFunction(v) || isSyncAGeneratorFunction(v)
Type.isSyncGeneratorFunction(v)		// return 'GeneratorFunction'===v.constructor.name
Type.isAsyncGeneratorFunction(v)	// return 'AsyncGeneratorFunction'===v.constructor.name
Type.isPromise(v)
Type.isIterator(v)        // return !isNullOrUndefined(v) && 'function'===typeof v[Symbol.iterator]
Type.isGenerator(v)			
Type.isObject(v)          // 上記以外のオブジェクト（Dict風に使用されたと思しきObject）
```

　`isClass`: 何らかのクラスである。（関数でない。インスタンスでない）


　型判定したいユースケース。

* メソッド
	* 引数チェック
	* バリデーション
	* メソッドのオーバーロード（引数、戻り値の型や数が違う同名メソッド（異なる処理をするよう振り分ける））


```javascript
Method.routing() // メソッドのオーバーロード
Method.Augs()    // 引数チェック
```

```javascript
function (...args) {
    Method.args(...args)
	Method.routing(
		[(...args)=>真偽, (...args)=>実行],
		[(...args)=>真偽, (...args)=>実行],
		[(...args)=>真偽, (...args)=>実行],
	)
}
Method.routing() // メソッドのオーバーロード
Method.Augs()    // 引数チェック
```

```javascript
function (...args) {
	Method.routing(
		[(args)=>真偽, (args)=>実行],
		[(args)=>真偽, (args)=>実行],
		[(args)=>真偽, (args)=>実行],
		[(args)=>真偽, (args)=>{throw new AugumentError(args)}],
	)
}
Method.routing() // メソッドのオーバーロード
Method.Augs()    // 引数チェック
```

## クラスを動的生成したい

```javascript
newClass('ClassName', {
	new: (...augs)=>,
    public: { // prefix: _ + getter/setter
		'name': {
			ini: '',
			get: ()=>this._name,
			set: (v)=>this._name = v,
		},
		'method': ()=>,
	},
	protected: { // prefix: _
		'': '',
		'': ()=>,		
		'': async()=>,		
		'': *()=>,		
		'': async*()=>,				
	},
	private: { // prefix: #
		'': '',
		'': ()=>,
		'': async()=>,		
		'': *()=>,		
		'': async*()=>,		
	},
	static: { // 修飾子 static
		'': '',
		'': ()=>,		
		'': async()=>,		
		'': *()=>,		
		'': async*()=>,		
	},
	fix: { // 修飾子 static 再代入不可
		'': '',
		'': ()=>,		
		'': async()=>,		
		'': *()=>,		
		'': async*()=>,		
	},
})
```

　元々以下のように`class {}`文でクラスオブジェクトを返す。

```javascript
const someClass = class {
	constructor() {}
}
```

　`Function()`関数で`eval()`と同等のことを実行すればクラスの動的生成できそう。

```javascript
return Function(`return class {{ClassName}} {}`)
```

　`Reflect.construct()`でインスタンスの動的生成できそう。

```javascript
const ins = Reflect.construct(C, args)
```

